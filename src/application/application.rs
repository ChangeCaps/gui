use super::super::*;
use math::*;
use glium;
use glium::{ 
    glutin::{
        event_loop::{
            EventLoop,
            ControlFlow,
        },
        event::{
            Event,
            StartCause,
            WindowEvent,
            ElementState,
        },
        window::WindowBuilder,
        ContextBuilder,
    },
    Display,
    Program,
    Surface,
};
use std::time::{Instant, Duration};
use std::collections::{HashMap, HashSet};
use std::thread;
use std::sync::{Arc, Mutex};
use std::sync::mpsc::sync_channel;
use std::sync::atomic::AtomicBool;

/// This is the struct responsible for running the program.
pub struct Application {
    pub(crate) title: &'static str,
    pub(crate) frame_time: Duration,
    pub(crate) aspect_ratio: Option<f32>,
    pub(crate) resizable: bool,
    pub(crate) window_size: Vec2<u32>,
    pub(crate) frame_size: Option<Vec2<f32>>,
    pub(crate) pixel_window_size: Option<Vec2<u32>>,
    pub(crate) depth_sorting: bool,
}

impl Application {
    /// Creates a new application
    pub fn new() -> Application {
        Application {
            title: "gui application",
            frame_time: Duration::from_secs_f32(1.0/60.0),
            aspect_ratio: None,
            resizable: true,
            frame_size: None,
            window_size: Vec2::new(800, 600),
            pixel_window_size: None,
            depth_sorting: false,
        }
    }

    /// Sets the title of the application
    pub fn with_title(mut self, title: &'static str) -> Application {
        self.title = title;
        self
    }

    /// Sets the fps of the application
    pub fn with_fps(mut self, fps: f32) -> Application {
        self.frame_time = Duration::from_secs_f32(1.0/fps);
        self
    }

    /// Sets the fame size
    pub fn with_frame_size(mut self, width: f32, height: f32) -> Application {
        self.frame_size = Some(Vec2::new(width, height));
        self
    }

    /// Sets the window of the application to non-resizable
    pub fn not_resizable(mut self) -> Application {
        self.resizable = false;
        self
    }

    /// Sets the window size of the application
    pub fn with_window_size(mut self, width: u32, height: u32) -> Application {
        self.window_size = Vec2::new(width, height);
        self
    }

    /// Starts the application in pixel-mode with a given size
    pub fn with_pixel_window_size(mut self, width: u32, height: u32) -> Application {
        self.pixel_window_size = Some(Vec2::new(width, height));
        self
    }

    /// Enables depth sorting
    pub fn with_depth_sorting(mut self, depth_sorting: bool) -> Application {
        self.depth_sorting = depth_sorting;
        self
    }

    /// Runs the application and takes a closure that returns a Box containing the first state
    pub fn run<F>(self, mut start: F) 
        where F: FnMut(&mut super::super::Loader) -> Box<dyn State>
    {
        //
        // initialization
        //

        #[cfg(debug_assertions)]
        println!("GUI::INITIALIZATION Initializing OPEN_GL"); 
        
        let event_loop = EventLoop::new();

        let wb = WindowBuilder::new()
            .with_resizable(self.resizable)
            .with_inner_size(
                glium::glutin::dpi::LogicalSize::new(self.window_size.x as f64, self.window_size.y as f64)
            )
            .with_title(self.title);

        let cb = ContextBuilder::new();

        let display = Display::new(wb, cb, &event_loop)
            .expect("GUI::INITIALIZATION Failed to create glium::Display");
        

        // programs

        #[cfg(debug_assertions)]
        println!("GUI::INITIALIZATION Loading Shaders");

        let simple_transform_fill = Program::from_source(
            &display, 
            include_str!("../shaders/vertex/simple_transform.glsl"), 
            include_str!("../shaders/fragment/fill.glsl"), 
            None
        );

        if let Err(err) = &simple_transform_fill {
            println!("{:?}", err)
        }

        let simple_transform_fill = simple_transform_fill.unwrap();


        #[cfg(debug_assertions)]
        println!("GUI::APPLICATION Starting Application");

        let mut mouse_position = Vec2::new(0.0, 0.0);
        let mut scaled_mouse_position = Vec2::new(0.0, 0.0);

        // calculate buffer_dimensions
        let buffer_dimensions = display.get_framebuffer_dimensions();
        let buffer_dimensions_u32 = Vec2::new(buffer_dimensions.0, buffer_dimensions.1);
        let buffer_dimensions = Vec2::new(buffer_dimensions.0 as f32, buffer_dimensions.1 as f32);

        // calculate window_dimensions set by the application
        let window_dimensions = Vec2::new(self.window_size.x as f32, self.window_size.y as f32);
        let frame_size = self.frame_size.unwrap_or(window_dimensions/window_dimensions.y * 2.0);

        // in some cases the size of the window generated by the OS would match the dimensions
        // specified by the application, a window_dimensions_multiplier is therefore calculated to
        // insure everything is drawn as expected
        let window_dimensions_multiplier = buffer_dimensions / window_dimensions;

        // calculate the aspect ratio
        let aspect_ratio = frame_size.x / frame_size.y;

        //
        // inputs
        //
        
        let mut keys_held = HashSet::new();
        let mut mouse_buttons_held = HashSet::new();
            
        let mut keys_pressed = HashSet::new();
        let mut keys_released = HashSet::new();

        let mut mouse_buttons_pressed = HashSet::new();
        let mut mouse_buttons_released = HashSet::new();


        #[cfg(debug_assertions)]
        println!("GUI::APPLICATION Running start function");

        //
        // loader
        //

        let mut image_indecies = HashMap::new();
        let mut image_dimensions = Vec::new();
        let mut font_indecies = HashMap::new();
        let mut font_character_infos = Vec::new(); 
        let mut font_dimensions = Vec::new();
        let mut text_inputs = Vec::new();

        let mut loader = super::super::Loader {
            display: &display,
            image_indecies: &mut image_indecies,
            font_indecies: &mut font_indecies,
            images: Vec::new(),
            fonts: Vec::new(),
            image_dimensions: &mut image_dimensions,
            font_dimensions: &mut font_dimensions,
            font_character_infos: &mut font_character_infos,
            text_inputs: &mut text_inputs,
        };

        let states: Arc<Mutex<Vec<Box<dyn State>>>> = Arc::new(Mutex::new(vec![start(&mut loader)]));

        
        let (image_atlas, image_positions, image_atlas_dimensions) = crate::texture_atlas::crate_atlas(&display, &mut loader.images, &mut loader.image_dimensions);
        let (font_atlas, font_positions, font_atlas_dimensions) = crate::texture_atlas::crate_atlas(&display, &mut loader.fonts, &mut loader.font_dimensions);

        // if pixel mode is set, there is no reason to keep remaking the frame buffer every frame
        // therefore we make it now and clear it every frame which is considerably faster

        let size = self.pixel_window_size.unwrap_or(buffer_dimensions_u32);

        // create texture_buffer
        let mut texture_buffer = glium::texture::texture2d::Texture2d::empty(
            &display,
            size.x, 
            size.y
        ).expect("failed to create texture buffer");

        // used to ensure that we don't go above the desired frame rate
        let mut next_frame_time = Instant::now() + self.frame_time;

        // init buffers
        let mut line_point_buffer = glium::buffer::Buffer::<[[f32; 4]]>::new(
            &display, 
            &[],
            glium::buffer::BufferType::ArrayBuffer,
            glium::buffer::BufferMode::Default,
        ).unwrap();

        let mut line_width_buffer = glium::buffer::Buffer::<[f32]>::new(
            &display, 
            &[],
            glium::buffer::BufferType::ArrayBuffer,
            glium::buffer::BufferMode::Default,
        ).unwrap();

        let mut vertex_buffer = glium::VertexBuffer::new(&display, &[]).unwrap();

        let state_data = Arc::new(Mutex::new(StateData {
            delta_time: 0.016,
            frame_dimensions: Vec2::new(aspect_ratio * 2.0, 2.0),
            scaled_frame_dimensions: Vec2::new(aspect_ratio * 2.0, 2.0),
            window_dimensions: Vec2::new(self.window_size.x as f32, self.window_size.y as f32),
            aspect_ratio,
            mouse_position,
            scaled_mouse_position,
            keys_pressed: keys_pressed.clone(),
            keys_held: keys_held.clone(),
            keys_released: keys_released.clone(),
            mouse_buttons_pressed: mouse_buttons_pressed.clone(),
            mouse_buttons_held: mouse_buttons_held.clone(),
            mouse_buttons_released: mouse_buttons_released.clone(),
        }));

        #[cfg(debug_assertions)]
        println!("GUI::APPLICATION Starting threads");

        let running = Arc::new(AtomicBool::new(true));

        //
        // drawing thread
        //

        let (drawing_data_sender, drawing_data_receiver) = sync_channel::<DrawingData>(1);
        let (main_drawing_data_sender, main_drawing_data_receiver) = sync_channel::<DrawingData>(1);

        // honestly this code is garbage, I hate it

        let draw_thread = {    
            let drawing_data = DrawingData {
                frame_size,
                line_points:                Vec::new(),
                line_widths:                Vec::new(),
                verts:                      Vec::new(),

                mask_shapes:                Vec::new(),
                rect_mask_positions:        Vec::new(),
                rect_mask_sizes:            Vec::new(),
                rect_mask_rotations:        Vec::new(),

                // FIXME: cloning is bad, find another way
                image_indecies:             image_indecies.clone(),
                image_dimensions:           image_dimensions.clone(),
                font_indecies:              font_indecies.clone(),
                font_dimensions:            font_dimensions.clone(),
                font_character_infos:       font_character_infos.clone(),
                scaled_aspect_ratio:        aspect_ratio,
                aspect_ratio:               aspect_ratio,
                font_atlas_dimensions:      font_atlas_dimensions,
                font_positions:             font_positions.clone(),
                image_atlas_dimensions:     image_atlas_dimensions,
                image_positions:            image_positions.clone(),
            };    
            let states = states.clone();
            let state_data = state_data.clone();
            let mut last_frame_vertex_count = 0;
            let frame_time = self.frame_time.clone();
            let running = running.clone();

            // running drawing thread 
            thread::spawn(move || {
                while running.load(std::sync::atomic::Ordering::SeqCst) {
                    let draw_start = Instant::now();

                    {
                        let states = { 
                            states.lock().unwrap().clone()
                        };
                        
                        let mut drawing_data = main_drawing_data_receiver.try_recv().unwrap_or_else(|_| drawing_data.clone());
                        

                        let state_data = {
                            state_data.lock().unwrap().clone()
                        };

                        drawing_data.verts = Vec::with_capacity(last_frame_vertex_count);

                        let index = states.len() - 1;

                        let mut frame = Frame { 
                            drawing_data: &mut drawing_data,
                        };

                        // run draw for current state
                        states[index].draw(
                            &mut frame,
                            &state_data,
                        );

                        // run shadow draw for all states
                        states.iter().for_each(|state| state.shadow_draw(
                            &mut frame,
                            &state_data,
                        )); 

                        // set last frame vertex count
                        last_frame_vertex_count = drawing_data.verts.len();

                        let _ = drawing_data_sender.try_send(drawing_data);
                    }

                    frame_time.checked_sub(Instant::now().duration_since(draw_start)).map(|duration| {
                        thread::sleep(duration);
                    });
                }
            })
        };

        //
        // update thread
        //

        let update_thread = {
            let states = states.clone();
            let state_data = state_data.clone();
            let mut last_update_time = Instant::now();
            let running = running.clone();

            // running update thread
            thread::spawn(move || {
                while running.load(std::sync::atomic::Ordering::SeqCst) {
                    let update_start = Instant::now();

                    {
                        let delta_time = Instant::now().duration_since(last_update_time).as_secs_f32();
                        last_update_time = Instant::now();

                        let mut states = states.lock().unwrap();
                        let mut state_data = {
                            state_data.lock().unwrap()
                        };

                        let index = states.len() - 1;

                        // run update for current state
                        let trans = states[index].update(&state_data);
            
                        // run shadow update for all states
                        states.iter_mut().for_each(|state| state.shadow_update(&state_data));

                        match trans {
                            Transition::Trans(state) => {
                                *states = vec![state];
                            },
                            Transition::Push(state) => {
                                states.push(state);
                            },
                            Transition::Pop => {
                                states.pop();

                                if states.len() == 0 {
                                    running.store(false, std::sync::atomic::Ordering::SeqCst);
                                }
                            },
                            Transition::None => (),
                        }
                        
                        state_data.delta_time = delta_time;
                    }
                    
                    std::time::Duration::from_secs_f32(1.0/60.0).checked_sub(Instant::now().duration_since(update_start)).map(|duration| {
                        thread::sleep(duration);
                    });
                }
            })
        };

        let mut draw_thread = Some(draw_thread);
        let mut update_thread = Some(update_thread);

        let mut join_threads = move || {
            let draw_thread = std::mem::replace(&mut draw_thread, None);
            let update_thread = std::mem::replace(&mut update_thread, None);  

            draw_thread.map(|thread| thread.join());
            update_thread.map(|thread| thread.join());
        };

        #[cfg(debug_assertions)]
        println!("GUI::APPLICATION Running main loop");

        // main loop
        event_loop.run(move |event, _, flow| { 
            if !running.load(std::sync::atomic::Ordering::SeqCst) {
                join_threads();     

                *flow = ControlFlow::Exit;

                return;
            }

            // update next_frame_time
            if next_frame_time <= Instant::now() {
                next_frame_time = Instant::now() + self.frame_time;
            }

            // set ControlFlow as to wait until the time for the next frame is reached before
            // redrawing
            *flow = ControlFlow::WaitUntil(next_frame_time);

            // get window dimensions
            let dims = display.get_framebuffer_dimensions();

            // dims as f32
            let w = dims.0 as f32;
            let h = dims.1 as f32;

            let window_dimensions = Vec2::new(w, h);
            
            // used for scaling shapes
            let scaled_aspect_ratio = w / h;  

            // event handling 
            match event {
                Event::WindowEvent {event, ..} => match event {
                    // if the window requests closing it, do so
                    WindowEvent::CloseRequested => {
                        running.store(false,std::sync::atomic::Ordering::SeqCst);

                        join_threads();

                        *flow = ControlFlow::Exit;

                        return;
                    },
                    // update cursor position when it is moved
                    WindowEvent::CursorMoved {position, ..} => {
                        mouse_position = (Vec2::new(
                            position.x as f32, 
                            position.y as f32
                        ) * window_dimensions_multiplier 
                          / window_dimensions * 2.0 - 1.0) * (frame_size.y / 2.0);
                        mouse_position.y = -mouse_position.y;

                        scaled_mouse_position = mouse_position;
                        scaled_mouse_position.x *= scaled_aspect_ratio;

                        mouse_position.x *= aspect_ratio;

                        return;
                    },
                    // record keyboard inputs
                    WindowEvent::KeyboardInput {input, ..} => {
                        match input.state {
                            ElementState::Pressed => {
                                input.virtual_keycode.map(|key| { 
                                    keys_held.insert(key);
                                    keys_pressed.insert(key);
                                });
                            },
                            ElementState::Released => { 
                                input.virtual_keycode.map(|key| { 
                                    keys_held.remove(&key);
                                    keys_released.insert(key);
                                });
                            }
                        }
                        
                        return;
                    },
                    // record mouse inputs
                    WindowEvent::MouseInput {button, state, ..} => {
                        match state {
                            ElementState::Pressed => {
                                mouse_buttons_held.insert(button);
                                mouse_buttons_pressed.insert(button);
                            },
                            ElementState::Released => { 
                                mouse_buttons_held.remove(&button);
                                mouse_buttons_released.insert(button);
                            },
                        }

                        return;
                    },
                    WindowEvent::ReceivedCharacter(c) => { 
                        // go through each text inputs and modify their text according to the given
                        // character input
                        text_inputs.iter_mut().for_each(|input| {
                            // since the inputs are of the type Rc<RefCell<(String, bool)>> we need
                            // to use borrow_mut to mutate it
                            let mut s = input.borrow_mut();

                            // if the text input is not reading, do not modify its text
                            if !s.1 {
                                return;
                            }

                            match c as u8 {
                                // ignore carriage returns
                                13 => {
                                    
                                },
                                // in the case of backspace pop a character from the text
                                08 => {
                                    s.0.pop();
                                },
                                // default to pushing the character to the String
                                _ => {    
                                    s.0.push(c);
                                }
                            }
                        });                        

                        return;
                    },
                    WindowEvent::Resized(size) => {
                        if self.pixel_window_size.is_none() {
                            texture_buffer = glium::texture::texture2d::Texture2d::empty(
                                &display,
                                size.width as u32,
                                size.height as u32,
                            ).expect("failed to create texture buffer for resized window");
                        }
                    },
                    _ => return,
                }, 
                Event::NewEvents(cause) => match cause {
                    // update the screen if the time limit is reached
                    StartCause::ResumeTimeReached { .. } => (),
                    StartCause::Init => (),
                    _ => return,
                }, 
                _ => return,
            }
        
            let (_, _, aspect_ratio) = if let Some(size) = self.pixel_window_size {
                (size.x, size.y, size.x as f32/size.y as f32)
            } else {
                (dims.0, dims.1, aspect_ratio)
            };
          
            // run state functions
            {
                // FIXME: all of the is bad, please clean this up later
                let _ = main_drawing_data_sender.try_send(DrawingData {
                    frame_size,

                    line_points:                Vec::new(),
                    line_widths:                Vec::new(),
                    verts:                      Vec::new(),

                    // masks
                    mask_shapes:                Vec::new(),
                    rect_mask_positions:        Vec::new(),
                    rect_mask_sizes:            Vec::new(),
                    rect_mask_rotations:        Vec::new(),
    
                    // FIXME: cloning is bad, find another way
                    image_indecies:             image_indecies.clone(),
                    image_dimensions:           image_dimensions.clone(),
                    font_indecies:              font_indecies.clone(),
                    font_dimensions:            font_dimensions.clone(),
                    font_character_infos:       font_character_infos.clone(),
                    scaled_aspect_ratio:        scaled_aspect_ratio,
                    aspect_ratio:               aspect_ratio,
                    font_atlas_dimensions:      font_atlas_dimensions,
                    font_positions:             font_positions.clone(),
                    image_atlas_dimensions:     image_atlas_dimensions,
                    image_positions:            image_positions.clone(),
                });

                // something something state_data
                {
                    let mut data = state_data.lock().unwrap();

                    *data = StateData {
                        delta_time: 0.016,
                        frame_dimensions: if let Some(size) = self.pixel_window_size {
                            Vec2::new(size.x as f32, size.y as f32)
                        } else {
                            Vec2::new(aspect_ratio * 2.0, 2.0)
                        },
                        scaled_frame_dimensions: Vec2::new(aspect_ratio * 2.0, 2.0),
                        window_dimensions: Vec2::new(self.window_size.x as f32, self.window_size.y as f32),
                        aspect_ratio,
                        mouse_position,
                        scaled_mouse_position,
                        keys_pressed: keys_pressed.clone(),
                        keys_held: keys_held.clone(),
                        keys_released: keys_released.clone(),
                        mouse_buttons_pressed: mouse_buttons_pressed.clone(),
                        mouse_buttons_held: mouse_buttons_held.clone(),
                        mouse_buttons_released: mouse_buttons_released.clone(),
                    };
                }

                let drawing_data = drawing_data_receiver.try_recv();

                if drawing_data.is_err() {
                    return;
                }

                let mut drawing_data = drawing_data.unwrap();

                // clear color
                texture_buffer.as_surface().clear_color(0.0, 0.0, 0.0, 0.0); 

                // line buffers only remake buffers if needed
                if line_point_buffer.len() == drawing_data.line_points.len() && 
                    drawing_data.line_points.len() != 0 
                {
                    line_point_buffer.write(&drawing_data.line_points);
                } else if drawing_data.line_points.len() > 0 || line_point_buffer.len() > 0 {
                    line_point_buffer = glium::buffer::Buffer::<[[f32; 4]]>::new(
                        &display, 
                        &drawing_data.line_points,
                        glium::buffer::BufferType::ArrayBuffer,
                        glium::buffer::BufferMode::Default,
                    ).unwrap();
                }

                if line_width_buffer.len() == drawing_data.line_widths.len() && 
                    drawing_data.line_widths.len() != 0 
                {
                    line_width_buffer.write(&drawing_data.line_widths);
                } else if drawing_data.line_widths.len() > 0 || line_width_buffer.len() > 0 {
                    line_width_buffer = glium::buffer::Buffer::<[f32]>::new(
                        &display, 
                        &drawing_data.line_widths,
                        glium::buffer::BufferType::ArrayBuffer,
                        glium::buffer::BufferMode::Default,
                    ).unwrap();
                }

                // masks
                let mask_shape_buffer = glium::buffer::Buffer::<[[i32; 2]]>::new(
                    &display, 
                    &drawing_data.mask_shapes,
                    glium::buffer::BufferType::ArrayBuffer,
                    glium::buffer::BufferMode::Default,
                ).unwrap();

                let rect_mask_position_buffer = glium::buffer::Buffer::<[[f32; 2]]>::new(
                    &display, 
                    &drawing_data.rect_mask_positions,
                    glium::buffer::BufferType::ArrayBuffer,
                    glium::buffer::BufferMode::Default,
                ).unwrap();

                let rect_mask_size_buffer = glium::buffer::Buffer::<[[f32; 2]]>::new(
                    &display, 
                    &drawing_data.rect_mask_sizes,
                    glium::buffer::BufferType::ArrayBuffer,
                    glium::buffer::BufferMode::Default,
                ).unwrap();

                let rect_mask_rotation_buffer = glium::buffer::Buffer::<[[[f32; 2]; 2]]>::new(
                    &display, 
                    &drawing_data.rect_mask_rotations,
                    glium::buffer::BufferType::ArrayBuffer,
                    glium::buffer::BufferMode::Default,
                ).unwrap();


                // uniforms for scaling draw call
                let uniforms = uniform!{
                    window_dimensions: window_dimensions.as_array(),
                    aspect_ratio: aspect_ratio,

                    // line buffers
                    line_point_buffer: &line_point_buffer,
                    line_width_buffer: &line_width_buffer,

                    // image
                    image_atlas: &image_atlas,
                    image_atlas_dimensions: image_atlas_dimensions.as_array(),

                    // text
                    font_atlas: &font_atlas,
                    font_atlas_dimensions: font_atlas_dimensions.as_array(),

                    // masks
                    mask_shape_buffer: &mask_shape_buffer,

                    // rect mask
                    rect_mask_position_buffer: &rect_mask_position_buffer,
                    rect_mask_size_buffer: &rect_mask_size_buffer,
                    rect_mask_rotation_buffer: &rect_mask_rotation_buffer,
                }; 

                if drawing_data.verts.len() > 0 { 
                    if self.depth_sorting {
                        drawing_data.verts.sort_by(|a, b| a.depth.partial_cmp(&b.depth).unwrap_or(std::cmp::Ordering::Equal));
                    }

                    if vertex_buffer.len() == drawing_data.verts.len() && drawing_data.verts.len() > 0 {
                        vertex_buffer.write(&drawing_data.verts);
                    } else if drawing_data.verts.len() > 0 || vertex_buffer.len() > 0 {
                        vertex_buffer = glium::VertexBuffer::new(&display, &drawing_data.verts).unwrap();
                    }

                    let draw_parameters = glium::draw_parameters::DrawParameters {
                        blend: glium::Blend::alpha_blending(),  
                        .. Default::default()
                    };
                
                    let frame = display.draw();

                    // draw the frame buffer to the window and handle errors
                    let _ = texture_buffer.as_surface().draw(&vertex_buffer,
                                       &glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList), 
                                       &simple_transform_fill,
                                       &uniforms,
                                       &draw_parameters); 

                    texture_buffer.as_surface().blit_whole_color_to(
                        &frame,
                        &glium::BlitTarget {
                            left: 0,
                            bottom: 0,
                            width: dims.0 as i32,
                            height: dims.1 as i32
                        },
                        glium::uniforms::MagnifySamplerFilter::Nearest
                    );
                    
                    frame.finish()
                        .expect("GUI::APPLICATION Failed to finish frame");
                }
            }; 

            // reset keypressed and released
            keys_pressed = HashSet::new();
            keys_released = HashSet::new();
            
            // reset mousepressed and released
            mouse_buttons_pressed = HashSet::new();
            mouse_buttons_released = HashSet::new();
        }); 
    }
}



